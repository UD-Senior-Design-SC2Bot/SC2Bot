\documentclass{article}

\usepackage{amsmath}

\begin{document}
	\begin{enumerate}
		\item Let:
		\begin{itemize}
			\item U be the unit moved
			\item M be the sequence of moves m that result in U collecting all the minerals
			\item $M_{current}$ be the M generated in the current iteration of the algorithm
			\item $M_{prev}$ be the M from the previous iteration of the algorithm
			\item T be the total time it takes to make all moves m in M
			\item $\epsilon \in [0, 1]$ be the parameter for randomness
		\end{itemize}
		\item Pre-load the bot with the set of moves M and decide a value for $\epsilon$. Initialize $M_{current}$ as an empty sequence.
		\item While there are still minerals to collect, the bot will refer to the function $f(m, \epsilon)$ to decide it's next move. The function will generate a random decimal number $n \in [0, 1]$, and return the next move $m_{next}$ in the given $M_{prev}$ if $n < \epsilon$. The function will return a new random direction $m_{random}$ if $n \geq \epsilon$.
			\newline
			\newline
			$m_{next} = \begin{cases} 
									m_{next} & n < \epsilon \\
									m_{random} & n >= \epsilon
					   			\end{cases}$
	   		  \newline
	   		  \newline
	   	\item Add $m_{next}$ to the sequence $M_{current}$
	   	\item Once all the minerals are collected, we compare the T of the current run to the T of the previous run. Let the T's be $T_{current}$ and $T_{prev}$ respectively. We now update the M used for the next generation, which we will refer to as $M_{next}$, as the M whose time corresponds to the lesser of $T_{current}$ or $T_{prev}$.
	   		\newline
	   		\newline
	   		  $M_{next} = \begin{cases} 
							   		  M_{current} & T_{current} < T_{prev} \\
							   		  M_{prev} & T_{current} \geq T_{prev}
							   	   \end{cases}$
	\end{enumerate}
	With enough iterations, this random movement algorithm will converge to a fastest time.
\end{document}
